"""
TG-–±–æ—Ç: –¥–æ—Å—Ç—É–ø –∫ –º–µ–Ω—é —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ –∞–Ω–∫–µ—Ç—ã, ¬´—Ä–∞–Ω–¥–æ–º–Ω—ã–π¬ª —Ç–æ–ø –Ω–µ–¥–µ–ª–∏,
—Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∫–æ–º–∞–Ω–¥ –±–µ–∑ –ø—Ä–æ—Ñ–∏—Ç–æ–≤, —Ç—Ä–µ—Ç—å—è —Å—Å—ã–ª–∫–∞ –Ω–∞ –≥—Ä—É–ø–ø–æ–≤–æ–π —á–∞—Ç
–∏ –≤–Ω–µ—à–Ω–∏–π —Ñ–∞–π–ª team_members.txt —Å–æ —Å–ø–∏—Å–∫–æ–º ¬´—É—á–∞—Å—Ç–Ω–∏–∫:—Ç–∏–º–ª–∏–¥–µ—Ä¬ª.

‚Ä¢ Python 3.10+
‚Ä¢ aiogram 3.x
‚Ä¢ –í .env –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å WELCOME_BOT_TOKEN  –∏  MY_ID (ID –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞)
‚Ä¢ –°–æ–∑–¥–∞–π—Ç–µ —Ä—è–¥–æ–º team_members.txt   (UTF-8, –ø–æ —Å—Ç—Ä–æ–∫–µ ¬´member:leader¬ª)
"""

import os, random, time, logging, datetime as dt
from aiogram import Bot, Dispatcher, types
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.context import FSMContext
from aiogram.filters.state import State, StatesGroup
from aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder
from aiogram.filters import Command
from aiogram.enums import ParseMode
from dotenv import load_dotenv

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  CONFIG  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
load_dotenv()

BOT_TOKEN  = os.getenv("WELCOME_BOT_TOKEN")
ADMIN_ID   = int(os.getenv("MY_ID"))         # ID, –∫—É–¥–∞ –ª–µ—Ç—è—Ç –∞–Ω–∫–µ—Ç—ã

MAIN_CHANNEL_LINK     = "https://t.me/+NpcxCSbz0VxjMjMy"
PAYMENTS_CHANNEL_LINK = "https://t.me/+ojyK0KkEw-E4NDRi"
GROUP_CHAT_LINK       = "https://t.me/YourGroupChat"   # ‚Üê –∑–∞–º–µ–Ω–∏—Ç–µ —Å—Å—ã–ª–∫—É
CHILL_MANOFF_LINK     = "https://t.me/Chill_manoff"

WHAT_WE_DO_LINK     = "https://telegra.ph/Nashe-napravlenie-05-22"
ELECTRUM_SETUP_LINK = "https://telegra.ph/Ustanovka-i-nastrojka-Electrum-05-23"
CANCEL_TX_LINK      = "https://telegra.ph/OTMENA-BTC-TRANZAKCII-05-31"
MANAGER_GUIDE_LINK  = "https://telegra.ph/INSTRUKCIYA-DLYA_MENEDZhERA--PERVICHNAYA-OBRABOTKA-ZAYAVKI-05-24"

logging.basicConfig(level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

bot      = Bot(BOT_TOKEN)
storage  = MemoryStorage()
dp       = Dispatcher(storage=storage)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TEAM MEMBERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def load_team_members(file_path: str = "team_members.txt"):
    """
    team_members.txt  ‚Üê –∫–∞–∂–¥–∞—è —Å—Ç—Ä–æ–∫–∞ ¬´member:leader¬ª
    –í–æ–∑–≤—Ä–∞—â–∞–µ–º: dict{leader: [members]},  list(all_members), list(all_teams)
    """
    teams: dict[str, list[str]] = {}
    try:
        with open(file_path, encoding="utf-8") as f:
            for line in f:
                if ":" in line:
                    member, leader = map(str.strip, line.split(":", 1))
                    teams.setdefault(leader, []).append(member)
    except FileNotFoundError:
        logger.warning("–§–∞–π–ª %s –Ω–µ –Ω–∞–π–¥–µ–Ω ‚Äì —Å–ø–∏—Å–∫–∏ –±—É–¥—É—Ç –ø—É—Å—Ç—ã–º–∏", file_path)
    return teams, [m for lst in teams.values() for m in lst], list(teams.keys())

TEAM_MEMBERS, ALL_MEMBERS, ALL_TEAMS = load_team_members()

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ USER RUNTIME STORAGE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
user_data: dict[int, dict] = {}

def get_user(user_id: int) -> dict:
    if user_id not in user_data:
        user_data[user_id] = {
            "wallets": [],
            "last_generation": None,
            "total_profit": 0,
            "weekly_profit": 0,
            "referrals": 0,
            "application_done": False
        }
    return user_data[user_id]

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ RANKS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
RANKS = {
    "–§—Ä–µ—à–º–µ–Ω": 0,
    "–ì—Ä–∞–π–Ω–¥–µ—Ä": 2000,
    "–í–µ—Ç–µ—Ä–∞–Ω": 5000,
    "–≠–ª–∏—Ç–∞": 10000,
    "–õ–µ–≥–µ–Ω–¥–∞": 20000
}

def get_next_rank(total: int):
    current = "–§—Ä–µ—à–º–µ–Ω"
    for r, val in RANKS.items():
        if total >= val:
            current = r
    keys = list(RANKS)
    idx  = keys.index(current)
    if idx < len(keys) - 1:
        nxt = keys[idx+1]
        need = RANKS[nxt] - total
    else:
        nxt, need = "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π", 0
    return current, nxt, need

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPER GENERATORS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def generate_wallets():
    """—Ç—Ä–∏ –ø–∞—Ä—ã ETH/TRX, –¥–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è"""
    res = []
    for _ in range(3):
        res.append({
            "eth": "0x" + "".join(random.choices("0123456789abcdef", k=40)),
            "trx": "T"  + "".join(random.choices("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", k=33)),
            "created": dt.datetime.now().strftime("%d.%m.%Y")
        })
    return res

def random_top_workers(k: int = 10):
    """–ø—Å–µ–≤–¥–æ—Å–ª—É—á–∞–π–Ω—ã–π —Ç–æ–ø —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –Ω–∞ –Ω–æ–º–µ—Ä –Ω–µ–¥–µ–ª–∏"""
    seed_val = dt.datetime.now().isocalendar().week
    random.seed(seed_val)
    sample = random.sample(ALL_MEMBERS, min(k, len(ALL_MEMBERS)))
    top = [{
        "name": m,
        "amount": random.randint(1000, 6000),
        "profits": random.randint(1, 15)
    } for m in sample]
    return sorted(top, key=lambda x: x["amount"], reverse=True)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FSM –∞–Ω–∫–µ—Ç—ã ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class Application(StatesGroup):
    waiting_for_name       = State()
    waiting_for_experience = State()
    waiting_for_hours      = State()
    waiting_for_wallet     = State()

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ACCESS DECORATOR ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def require_application(handler):
    async def wrapper(message: types.Message, *args, **kwargs):
        if not get_user(message.from_user.id)["application_done"]:
            await message.answer("‚ö†Ô∏è –°–Ω–∞—á–∞–ª–∞ –∑–∞–ø–æ–ª–Ω–∏—Ç–µ –∞–Ω–∫–µ—Ç—É: –Ω–∞–∂–º–∏—Ç–µ /start –∏ –≤—ã–±–µ—Ä–∏—Ç–µ ¬´–ü–æ–¥–∞—Ç—å –∑–∞—è–≤–∫—É¬ª.")
            return
        return await handler(message, *args, **kwargs)
    return wrapper

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ MAIN MENU KB ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def main_menu():
    kb = ReplyKeyboardBuilder()
    kb.row(types.KeyboardButton(text="–ú–∞–Ω—É–∞–ª—ã"))
    kb.row(types.KeyboardButton(text="üß¨ –ú–æ–∏ –∫–æ—à–µ–ª—å–∫–∏"))
    kb.row(types.KeyboardButton(text="üìà –ú–æ—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"),
           types.KeyboardButton(text="üîù –¢–æ–ø –Ω–µ–¥–µ–ª–∏"))
    kb.row(types.KeyboardButton(text="üîù –ö–æ–º–∞–Ω–¥—ã"),
           types.KeyboardButton(text="üíå –ö–∞–Ω–∞–ª"))
    kb.row(types.KeyboardButton(text="ü§ù –ò–Ω–≤–∞–π—Ç"),
           types.KeyboardButton(text="üè¶ –í—ã–ø–ª–∞—Ç—ã"))
    return kb.as_markup(resize_keyboard=True)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ /start ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
@dp.message(Command("start"))
async def cmd_start(msg: types.Message, state: FSMContext):
    await state.clear()
    apply_btn = InlineKeyboardBuilder().add(
        types.InlineKeyboardButton(text="‚úÖ –ü–æ–¥–∞—Ç—å –∑–∞—è–≤–∫—É", callback_data="apply_from_start")
    )
    welcome = (
        "üñº <b>–î–û–ë–†–û –ü–û–ñ–ê–õ–û–í–ê–¢–¨!</b>\n\n"
        "–û–∑–Ω–∞–∫–æ–º—å—Å—è —Å –ø—Ä–∞–≤–∏–ª–∞–º–∏ –ø—Ä–æ–µ–∫—Ç–∞ –ø—Ä–µ–∂–¥–µ, —á–µ–º –ø–æ–¥–∞—Ç—å –∑–∞—è–≤–∫—É.\n\n"
        "‚õî –†–∞–∑–º–µ—â–µ–Ω–∏–µ 18+ ‚Äì –ë–ê–ù\n"
        "‚õî –†–µ–∫–ª–∞–º–∞ –±–µ–∑ —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–∏—è ‚Äì –ë–ê–ù\n"
        "‚õî –ü–æ–ø—Ä–æ—à–∞–π–Ω–∏—á–µ—Å—Ç–≤–æ ‚Äì –º—É—Ç 24 —á\n"
        "‚õî –ü–æ–ª–∏—Ç–∏—á–µ—Å–∫–∏–µ —Å—Ä–∞—á–∏ ‚Äì –ë–ê–ù\n"
        "‚õî –°–∞–±–æ—Ç–∞–∂ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ ‚Äì –ë–ê–ù\n"
        "‚õî –ü—Ä–∏—ë–º –ø–ª–∞—Ç–µ–∂–µ–π –Ω–∞ –ª–∏—á–Ω—ã–µ –∫–æ—à–µ–ª—å–∫–∏ ‚Äì –ë–ê–ù"
    )
    await msg.answer(welcome, parse_mode=ParseMode.HTML, reply_markup=apply_btn.as_markup())
    await msg.answer("üîπ –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –≤ –º–µ–Ω—é:", reply_markup=main_menu())

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  –∞–Ω–∫–µ—Ç–∞: –∑–∞–ø—É—Å–∫ —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
@dp.callback_query(lambda c: c.data == "apply_from_start")
async def cb_apply(cb: types.CallbackQuery, state: FSMContext):
    await state.set_state(Application.waiting_for_name)
    await cb.message.answer("1. –£–∫–∞–∂–∏ —Å–≤–æ—ë –∏–º—è –∏ –≤–æ–∑—Ä–∞—Å—Ç:")
    await cb.answer()

@dp.message(lambda m: m.text == "–ü–æ–¥–∞—Ç—å –∑–∞—è–≤–∫—É")
async def manual_apply(msg: types.Message, state: FSMContext):
    await state.set_state(Application.waiting_for_name)
    await msg.answer("1. –£–∫–∞–∂–∏ —Å–≤–æ—ë –∏–º—è –∏ –≤–æ–∑—Ä–∞—Å—Ç:")

@dp.message(Application.waiting_for_name)
async def app_name(msg: types.Message, state: FSMContext):
    await state.update_data(name_age=msg.text)
    await state.set_state(Application.waiting_for_experience)
    await msg.answer("2. –û–ø—ã—Ç —Ä–∞–±–æ—Ç—ã –Ω–∞ –∑–≤–æ–Ω–∫–∞—Ö/—á–∞—Ç–∞—Ö? –ï—Å–ª–∏ –±—ã–ª ‚Äì –æ–ø–∏—à–∏.")

@dp.message(Application.waiting_for_experience)
async def app_exp(msg: types.Message, state: FSMContext):
    await state.update_data(experience=msg.text)
    await state.set_state(Application.waiting_for_hours)
    await msg.answer("3. –°–∫–æ–ª—å–∫–æ –≤—Ä–µ–º–µ–Ω–∏ –≥–æ—Ç–æ–≤ —É–¥–µ–ª—è—Ç—å —Ä–∞–±–æ—Ç–µ?")

@dp.message(Application.waiting_for_hours)
async def app_hours(msg: types.Message, state: FSMContext):
    await state.update_data(hours=msg.text)
    await state.set_state(Application.waiting_for_wallet)
    await msg.answer("4. –£–∫–∞–∂–∏ BTC-–∫–æ—à–µ–ª—ë–∫ –¥–ª—è —Ä–∞–±–æ—Ç—ã:")

@dp.message(Application.waiting_for_wallet)
async def app_wallet(msg: types.Message, state: FSMContext):
    await state.update_data(btc_wallet=msg.text)
    data = await state.get_data()

    text = (
        "üìÑ <b>–ù–æ–≤–∞—è –∞–Ω–∫–µ—Ç–∞</b>\n\n"
        f"üë§ <b>–ò–º—è –∏ –≤–æ–∑—Ä–∞—Å—Ç:</b> {data['name_age']}\n"
        f"üíº <b>–û–ø—ã—Ç:</b> {data['experience']}\n"
        f"‚è± <b>–ß–∞—Å—ã:</b> {data['hours']}\n"
        f"üí∞ <b>BTC:</b> {data['btc_wallet']}\n"
        f"üÜî <b>ID:</b> {msg.from_user.id}"
    )
    try:
        await bot.send_message(ADMIN_ID, text, parse_mode=ParseMode.HTML)
    except Exception as e:
        logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∞–Ω–∫–µ—Ç—É –∞–¥–º–∏–Ω—É: %s", e)

    await msg.answer(
        "‚úÖ <b>–ê–Ω–∫–µ—Ç–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞.</b>\n–°–∫–æ—Ä–æ —Å —Ç–æ–±–æ–π —Å–≤—è–∂–µ—Ç—Å—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä @Chill_manoff",
        parse_mode=ParseMode.HTML, reply_markup=main_menu()
    )

    links = InlineKeyboardBuilder().row(
        types.InlineKeyboardButton(text="üì¢ –ö–∞–Ω–∞–ª", url=MAIN_CHANNEL_LINK),
        types.InlineKeyboardButton(text="üí∏ –í—ã–ø–ª–∞—Ç—ã", url=PAYMENTS_CHANNEL_LINK),
        types.InlineKeyboardButton(text="üí¨ –ß–∞—Ç", url=GROUP_CHAT_LINK)
    )
    await msg.answer("–ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –Ω–∞—à–∏ —Ä–µ—Å—É—Ä—Å—ã:", reply_markup=links.as_markup())

    get_user(msg.from_user.id)["application_done"] = True
    await state.clear()

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  –ú–ï–ù–Æ: –ú–∞–Ω—É–∞–ª—ã / Wallets / ‚Ä¶  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
@dp.message(lambda m: m.text == "–ú–∞–Ω—É–∞–ª—ã")
@require_application
async def manuals(msg: types.Message):
    kb = InlineKeyboardBuilder()
    kb.add(types.InlineKeyboardButton(text="–ß–µ–º –∑–∞–Ω–∏–º–∞–µ–º—Å—è",       url=WHAT_WE_DO_LINK))
    kb.row(types.InlineKeyboardButton(text="–ù–∞—Å—Ç—Ä–æ–π–∫–∞ Electrum",   url=ELECTRUM_SETUP_LINK))
    kb.row(types.InlineKeyboardButton(text="–û—Ç–º–µ–Ω–∞ BTC —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π",url=CANCEL_TX_LINK))
    kb.row(types.InlineKeyboardButton(text="–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞", url=MANAGER_GUIDE_LINK))
    kb.row(types.InlineKeyboardButton(text="üë§ –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä",     url=CHILL_MANOFF_LINK))
    await msg.answer("üìö <b>–ú–∞–Ω—É–∞–ª—ã –ø—Ä–æ–µ–∫—Ç–∞</b>:", parse_mode=ParseMode.HTML, reply_markup=kb.as_markup())

@dp.message(lambda m: m.text == "üß¨ –ú–æ–∏ –∫–æ—à–µ–ª—å–∫–∏")
@require_application
async def my_wallets(msg: types.Message):
    user = get_user(msg.from_user.id)
    if not user["wallets"]:
        kb = InlineKeyboardBuilder().add(
            types.InlineKeyboardButton(text="üîê –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–ª—é—á–∏", callback_data="generate_wallets")
        )
        await msg.answer("‚ö†Ô∏è –ö–æ—à–µ–ª—å–∫–∏ –µ—â—ë –Ω–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã.", reply_markup=kb.as_markup())
        return

    text = "üîë <b>–í–∞—à–∏ –∫–æ—à–µ–ª—å–∫–∏</b>\n\n"
    for i, w in enumerate(user["wallets"], 1):
        text += (f"<b>–°–≤—è–∑–∫–∞ #{i}</b> (—Å–æ–∑–¥–∞–Ω–∞ {w['created']})\n"
                 f"‚Ä¢ ETH: <code>{w['eth']}</code>\n"
                 f"‚Ä¢ TRX: <code>{w['trx']}</code>\n\n")
    await msg.answer(text, parse_mode=ParseMode.HTML)

@dp.callback_query(lambda c: c.data == "generate_wallets")
async def cb_generate(cb: types.CallbackQuery):
    user = get_user(cb.from_user.id)
    now = time.time()
    if user["last_generation"] and now - user["last_generation"] < 86400:
        left = 86400 - (now - user["last_generation"])
        h, m = int(left//3600), int((left%3600)//60)
        await cb.message.answer(f"‚ö†Ô∏è –£–∂–µ –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–ª–∏. –ü–æ–≤—Ç–æ—Ä —á–µ—Ä–µ–∑ {h} —á {m} –º–∏–Ω.")
        await cb.answer(); return
    user["wallets"] = generate_wallets()
    user["last_generation"] = now
    txt = "üéâ <b>–ö–æ—à–µ–ª—å–∫–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã</b>\n\n"
    for i, w in enumerate(user["wallets"], 1):
        txt += f"<b>–°–≤—è–∑–∫–∞ #{i}</b>\n‚Ä¢ ERC20: <code>{w['eth']}</code>\n‚Ä¢ TRC20: <code>{w['trx']}</code>\n\n"
    await cb.message.answer(txt, parse_mode=ParseMode.HTML)
    await cb.answer()

@dp.message(lambda m: m.text == "üìà –ú–æ—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")
@require_application
async def my_stats(msg: types.Message):
    u = get_user(msg.from_user.id)
    cur, nxt, need = get_next_rank(u["total_profit"])
    await msg.answer(
        "üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</b>\n\n"
        f"üíµ –í—Å–µ–≥–æ: {u['total_profit']}$\n"
        f"üìÖ –ù–µ–¥–µ–ª—è: {u['weekly_profit']}$\n"
        f"üèÖ –†–∞–Ω–≥: {cur}\n\n"
        f"–î–æ –∑–≤–∞–Ω–∏—è {nxt}: {need}$\n"
        f"üí∏ –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è –≤—ã–ø–ª–∞—Ç–∞ (35%): {u['weekly_profit']*0.35}$",
        parse_mode=ParseMode.HTML
    )

@dp.message(lambda m: m.text == "üîù –¢–æ–ø –Ω–µ–¥–µ–ª–∏")
@require_application
async def top_week(msg: types.Message):
    top = random_top_workers(10)
    txt = "üèÜ <b>–¢–æ–ø –≤–æ—Ä–∫–µ—Ä–æ–≤ –Ω–µ–¥–µ–ª–∏</b>\n\n"
    for i, w in enumerate(top, 1):
        txt += f"{i}. <b>{w['name']}</b> ‚Äî {w['amount']}$, –ø—Ä–æ—Ñ–∏—Ç–æ–≤: {w['profits']}\n"
    txt += "\nüí∏ <b>–ö–∞–Ω–∞–ª –≤—ã–ø–ª–∞—Ç:</b> " + PAYMENTS_CHANNEL_LINK
    await msg.answer(txt, parse_mode=ParseMode.HTML)

@dp.message(lambda m: m.text == "üîù –ö–æ–º–∞–Ω–¥—ã")
@require_application
async def list_teams(msg: types.Message):
    txt = "üìã <b>–°–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥</b>\n\n" + "\n".join(f"‚Ä¢ {t}" for t in sorted(ALL_TEAMS))
    await msg.answer(txt, parse_mode=ParseMode.HTML)

@dp.message(lambda m: m.text == "üíå –ö–∞–Ω–∞–ª")
@require_application
async def channels(msg: types.Message):
    kb = InlineKeyboardBuilder().row(
        types.InlineKeyboardButton(text="üì¢ –ö–∞–Ω–∞–ª",  url=MAIN_CHANNEL_LINK),
        types.InlineKeyboardButton(text="üí∏ –í—ã–ø–ª–∞—Ç—ã", url=PAYMENTS_CHANNEL_LINK),
        types.InlineKeyboardButton(text="üí¨ –ß–∞—Ç",     url=GROUP_CHAT_LINK)
    )
    await msg.answer("üì¢ <b>–ù–∞—à–∏ –∫–∞–Ω–∞–ª—ã –∏ —á–∞—Ç</b>", parse_mode=ParseMode.HTML, reply_markup=kb.as_markup())

@dp.message(lambda m: m.text == "ü§ù –ò–Ω–≤–∞–π—Ç")
@require_application
async def invite(msg: types.Message):
    bot_username = (await bot.me()).username
    ref = msg.from_user.username or str(msg.from_user.id)
    link = f"https://t.me/{bot_username}?start={ref}"
    kb = InlineKeyboardBuilder().add(
        types.InlineKeyboardButton(text="üì§ –ü–æ–¥–µ–ª–∏—Ç—å—Å—è",
                                   url=f"tg://msg_url?url={link}&text=–ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–π—Å—è%20–∫%20–Ω–∞—à–µ–º—É%20–ø—Ä–æ–µ–∫—Ç—É!")
    )
    await msg.answer(
        "ü§ù <b>–ü—Ä–∏–≥–ª–∞—à–∞–π –¥—Ä—É–∑–µ–π –∏ –ø–æ–ª—É—á–∞–π –±–æ–Ω—É—Å—ã!</b>\n\n"
        f"–¢–≤–æ—è —Å—Å—ã–ª–∫–∞:\n<code>{link}</code>\n\n"
        "+5% –∫ –≤—ã–ø–ª–∞—Ç–µ –∑–∞ –∫–∞–∂–¥–æ–≥–æ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ä–µ—Ñ–µ—Ä–∞–ª–∞.",
        parse_mode=ParseMode.HTML, reply_markup=kb.as_markup()
    )

@dp.message(lambda m: m.text == "üè¶ –í—ã–ø–ª–∞—Ç—ã")
@require_application
async def payments(msg: types.Message):
    kb = InlineKeyboardBuilder().add(types.InlineKeyboardButton(text="üí∏ –ü–µ—Ä–µ–π—Ç–∏", url=PAYMENTS_CHANNEL_LINK))
    await msg.answer("üí∞ <b>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –≤—ã–ø–ª–∞—Ç–∞—Ö</b>\n\n–ü—Ä–æ—Ñ–∏—Ç—ã –ø—É–±–ª–∏–∫—É—é—Ç—Å—è –≤ –∫–∞–Ω–∞–ª–µ –≤—ã–ø–ª–∞—Ç.",
                     parse_mode=ParseMode.HTML, reply_markup=kb.as_markup())

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  RUN  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def main():
    logger.info("Bot started")
    await dp.start_polling(bot)

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
